{
  "progName": "Dungeon Generator",
  "htmlText": "<h3>Random Dungeon Generator Sample (Run again for a new map)</h3>\n<a href=\"http://bigbadwofl.me/random-dungeon-generator/\" target=\"_blank\">Source Webpage</a>\n<br/><br/>\n<canvas id='canvas'></canvas>\n\n",
  "scriptText": "// Random Dungeon Generator Sample taken from :\n// http://bigbadwofl.me/random-dungeon-generator/\n\n// this sample already encapsulated their variables, so i will just make sure\n// their names wont conflict and then\n// implement this cleanup callback function to release global variables\nfunction EVT_CleanSandbox() {\n\tdelete DungeonRenderer.canvas;\n  \tdelete DungeonRenderer.ctx;\n  \tdelete Dungeon.map;\n  \tdelete Dungeon.rooms;\n}\n\nvar Dungeon = {\n    map: null,\n    map_size: 64,\n    rooms: [],\n    Generate: function () {\n        this.map = [];\n        for (var x = 0; x < this.map_size; x++) {\n            this.map[x] = [];\n            for (var y = 0; y < this.map_size; y++) {\n                this.map[x][y] = 0;\n            }\n        }\n\n        var room_count = Helpers.GetRandom(10, 20);\n        var min_size = 5;\n        var max_size = 15;\n\n        for (var i = 0; i < room_count; i++) {\n            var room = {};\n\n            room.x = Helpers.GetRandom(1, this.map_size - max_size - 1);\n            room.y = Helpers.GetRandom(1, this.map_size - max_size - 1);\n            room.w = Helpers.GetRandom(min_size, max_size);\n            room.h = Helpers.GetRandom(min_size, max_size);\n\n            if (this.DoesCollide(room)) {\n                i--;\n                continue;\n            }\n            room.w--;\n            room.h--;\n\n            this.rooms.push(room);\n        }\n\n        this.SquashRooms();\n\n        for (i = 0; i < room_count; i++) {\n            var roomA = this.rooms[i];\n            var roomB = this.FindClosestRoom(roomA);\n\n            pointA = {\n                x: Helpers.GetRandom(roomA.x, roomA.x + roomA.w),\n                y: Helpers.GetRandom(roomA.y, roomA.y + roomA.h)\n            };\n            pointB = {\n                x: Helpers.GetRandom(roomB.x, roomB.x + roomB.w),\n                y: Helpers.GetRandom(roomB.y, roomB.y + roomB.h)\n            };\n\n            while ((pointB.x != pointA.x) || (pointB.y != pointA.y)) {\n                if (pointB.x != pointA.x) {\n                    if (pointB.x > pointA.x) pointB.x--;\n                    else pointB.x++;\n                } else if (pointB.y != pointA.y) {\n                    if (pointB.y > pointA.y) pointB.y--;\n                    else pointB.y++;\n                }\n\n                this.map[pointB.x][pointB.y] = 1;\n            }\n        }\n\n        for (i = 0; i < room_count; i++) {\n            var room = this.rooms[i];\n            for (var x = room.x; x < room.x + room.w; x++) {\n                for (var y = room.y; y < room.y + room.h; y++) {\n                    this.map[x][y] = 1;\n                }\n            }\n        }\n\n        for (var x = 0; x < this.map_size; x++) {\n            for (var y = 0; y < this.map_size; y++) {\n                if (this.map[x][y] == 1) {\n                    for (var xx = x - 1; xx <= x + 1; xx++) {\n                        for (var yy = y - 1; yy <= y + 1; yy++) {\n                            if (this.map[xx][yy] == 0) this.map[xx][yy] = 2;\n                        }\n                    }\n                }\n            }\n        }\n    },\n    FindClosestRoom: function (room) {\n        var mid = {\n            x: room.x + (room.w / 2),\n            y: room.y + (room.h / 2)\n        };\n        var closest = null;\n        var closest_distance = 1000;\n        for (var i = 0; i < this.rooms.length; i++) {\n            var check = this.rooms[i];\n            if (check == room) continue;\n            var check_mid = {\n                x: check.x + (check.w / 2),\n                y: check.y + (check.h / 2)\n            };\n            var distance = Math.min(Math.abs(mid.x - check_mid.x) - (room.w / 2) - (check.w / 2), Math.abs(mid.y - check_mid.y) - (room.h / 2) - (check.h / 2));\n            if (distance < closest_distance) {\n                closest_distance = distance;\n                closest = check;\n            }\n        }\n        return closest;\n    },\n    SquashRooms: function () {\n        for (var i = 0; i < 10; i++) {\n            for (var j = 0; j < this.rooms.length; j++) {\n                var room = this.rooms[j];\n                while (true) {\n                    var old_position = {\n                        x: room.x,\n                        y: room.y\n                    };\n                    if (room.x > 1) room.x--;\n                    if (room.y > 1) room.y--;\n                    if ((room.x == 1) && (room.y == 1)) break;\n                    if (this.DoesCollide(room, j)) {\n                        room.x = old_position.x;\n                        room.y = old_position.y;\n                        break;\n                    }\n                }\n            }\n        }\n    },\n    DoesCollide: function (room, ignore) {\n        for (var i = 0; i < this.rooms.length; i++) {\n            if (i == ignore) continue;\n            var check = this.rooms[i];\n            if (!((room.x + room.w < check.x) || (room.x > check.x + check.w) || (room.y + room.h < check.y) || (room.y > check.y + check.h))) return true;\n        }\n\n        return false;\n    }\n}\n\nvar DungeonRenderer = {\n    canvas: null,\n    ctx: null,\n    size: 512,\n    scale: 0,\n    Initialize: function () {\n        this.canvas = document.getElementById('canvas');\n        this.canvas.width = this.size;\n        this.canvas.height = this.size;\n        this.ctx = canvas.getContext('2d');\n        this.scale = this.canvas.width / Dungeon.map_size;\n    },\n    Update: function () {\n        for (var y = 0; y < Dungeon.map_size; y++) {\n            for (var x = 0; x < Dungeon.map_size; x++) {\n                var tile = Dungeon.map[x][y];\n                if (tile == 0) this.ctx.fillStyle = '#351330';\n                else if (tile == 1) this.ctx.fillStyle = '#64908A';\n                else this.ctx.fillStyle = '#424254';\n                this.ctx.fillRect(x * this.scale, y * this.scale, this.scale, this.scale);\n            }\n        }\n    }\n};\n\nvar Helpers = {\n    GetRandom: function (low, high) {\n        return~~ (Math.random() * (high - low)) + low;\n    }\n};\n\nDungeon.Generate();\nDungeonRenderer.Initialize();\nDungeonRenderer.Update(Dungeon.map);\n"
}