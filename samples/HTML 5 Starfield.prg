{
  "progName": "HTML 5 Starfield",
  "htmlText": "<!-- This sample was designed for mouseover events so it may stop animating if you tap it on touchscreen \n     Normally mouseover affects speed and mouseout stops animation.\n     For this reason i forced it to start animation immediately (without mousing into it) so it would\n     animate on touchscreen without mouse -->\n\n<CANVAS id=\"canvas\"></CANVAS>",
  "scriptText": "// shim layer with setTimeout fallback\n// from http://paulirish.com/2011/requestanimationframe-for-smart-animating/\nwindow.requestAnimFrame = (function(){\n  return  window.requestAnimationFrame       || \n          window.webkitRequestAnimationFrame || \n          window.mozRequestAnimationFrame    || \n          window.oRequestAnimationFrame      || \n          window.msRequestAnimationFrame     || \n          function( callback ){\n            window.setTimeout(callback, 1000 / 60);\n          };\n})();\n\n// just going to cleanup these reference variables to prevent\n// conflicts, the other variables are simple datatypes and can be overrideen\nvar sandboxVars = {\n  canvas: document.getElementById(\"canvas\"),\n  c: canvas.getContext(\"2d\")\n}\n\nfunction EVT_CleanSandbox() {\n  animate = false;\t// flag to stop animation loop\n  \n  // wait until next animation frame completes and then clean up canvas and context\n  // 300 ms should be fine even on machines only getting about 3.33 fps\n  setTimeout(function() {\n  \tdelete sandboxVars.canvas;\n  \tdelete sandboxVars.c;\n  }, 300);\n}\n\nvar numStars = 1000;\nvar radius = 1;\nvar focalLength = sandboxVars.canvas.width;\n\nvar centerX, centerY;\n\nvar stars = [], star;\nvar i;\n\n// kick off animation immediately\nvar animate = true;\n\ninitializeStars();\n\nfunction executeFrame(){\n  if(animate)\n    requestAnimFrame(executeFrame);\n  moveStars();\n  drawStars();\n}\n\nfunction initializeStars(){\n  centerX = sandboxVars.canvas.width / 2;\n  centerY = sandboxVars.canvas.height / 2;\n  \n  stars = [];\n  for(i = 0; i < numStars; i++){\n    star = {\n      x: Math.random() * canvas.width,\n      y: Math.random() * canvas.height,\n      z: Math.random() * canvas.width\n    };\n    stars.push(star);\n  }\n}\n\nfunction moveStars(){\n  for(i = 0; i < numStars; i++){\n    star = stars[i];\n    star.z--;\n    \n    if(star.z <= 0){\n      star.z = canvas.width;\n    }\n  }\n}\n\nfunction drawStars(){\n  var pixelX, pixelY, pixelRadius;\n  \n  // Resize to the screen\n  //if(canvas.width != window.innerWidth || canvas.width != window.innerWidth){\n  //  canvas.width = window.innerWidth;\n  //  canvas.height = window.innerHeight;\n  //  initializeStars();\n  //}\n  if(sandboxVars.canvas.width != 700){\n    sandboxVars.canvas.width = 700;\n    sandboxVars.canvas.height = 400;\n    initializeStars();\n  }\n  \n  sandboxVars.c.fillStyle = \"black\";\n  sandboxVars.c.fillRect(0,0, sandboxVars.canvas.width, sandboxVars.canvas.height);\n  sandboxVars.c.fillStyle = \"white\";\n  for(i = 0; i < numStars; i++){\n    star = stars[i];\n    \n    pixelX = (star.x - centerX) * (focalLength / star.z);\n    pixelX += centerX;\n    pixelY = (star.y - centerY) * (focalLength / star.z);\n    pixelY += centerY;\n    pixelRadius = radius * (focalLength / star.z);\n    \n    sandboxVars.c.beginPath();\n    sandboxVars.c.arc(pixelX, pixelY, pixelRadius, 0, 2 * Math.PI);\n    sandboxVars.c.fill();\n  }\n}\n\nsandboxVars.canvas.addEventListener(\"mousemove\",function(e){\n  focalLength = e.x;\n});\n\n// Kick off the animation when the mouse enters the canvas\nsandboxVars.canvas.addEventListener('mouseover', function(e){\n  animate = true;\n  executeFrame();\n});\n\n// Pause animation when the mouse exits the canvas\nsandboxVars.canvas.addEventListener(\"mouseout\",function(e){\n  mouseDown = false;\n  animate = false;\n});\n\n// Draw the first frame to start animation\nexecuteFrame();"
}